import json
import logging
from typing import Dict, List, Any
from .openrouter_client import OpenRouterClient

logger = logging.getLogger(__name__)

class VulnerabilityAnalyzer:
    def __init__(self):
        self.openrouter_client = OpenRouterClient()
        self.last_analysis_time = 0
        self.last_cost = 0.0
    
    async def analyze_batch(self, traces: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Analyze a batch of traces for vulnerabilities"""
        results = []
        
        for trace in traces:
            try:
                result = await self.analyze_single_trace(trace)
                results.append(result)
            except Exception as e:
                logger.error(f"Failed to analyze trace {trace.get('trace_id', 'unknown')}: {e}")
                results.append({
                    "trace_id": trace.get("trace_id", "unknown"),
                    "vulnerabilities": [],
                    "error": str(e)
                })
        
        return results
    
    async def analyze_single_trace(self, trace: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze a single trace for vulnerabilities"""
        prompt = self._build_vulnerability_prompt(trace)
        
        # Debug: Log the prompt being sent
        logger.info(f"🔍 VULNERABILITY ANALYSIS PROMPT for trace {trace.get('trace_id', 'unknown')}:")
        logger.info("=" * 80)
        logger.info(prompt)
        logger.info("=" * 80)
        
        messages = [
            {"role": "user", "content": prompt}
        ]
        
        response = await self.openrouter_client.chat_completion(messages)
        
        # Debug: Log the LLM response
        logger.info(f"🤖 LLM RESPONSE for trace {trace.get('trace_id', 'unknown')}:")
        logger.info("=" * 80)
        logger.info(response["content"])
        logger.info("=" * 80)
        
        # Update metrics
        self.last_analysis_time = response["response_time_ms"]
        self.last_cost = response["cost_usd"]
        
        # Parse LLM response
        vulnerabilities = self._parse_vulnerability_response(response["content"])
        
        return {
            "trace_id": trace["trace_id"],
            "vulnerabilities": vulnerabilities,
            "analysis_metadata": {
                "model": response["model"],
                "response_time_ms": response["response_time_ms"],
                "cost_usd": response["cost_usd"],
                "usage": response["usage"]
            }
        }
    
    def _build_vulnerability_prompt(self, trace: Dict[str, Any]) -> str:
        """Build comprehensive vulnerability detection prompt"""
        request_info = trace.get("request_info", {})
        execution_trace = trace.get("execution_trace", [])
        
        # Format execution trace for analysis
        trace_summary = self._format_execution_trace(execution_trace)
        
        prompt = f"""
あなたはWebアプリケーションセキュリティの専門家です。以下のRuby on Rails アプリケーションの実行トレースを分析し、OWASP Top 10 2021 に基づく脆弱性を検出してください。

## リクエスト情報
- Method: {request_info.get('method', 'UNKNOWN')}
- Path: {request_info.get('path', 'unknown')}
- Parameters: {json.dumps(request_info.get('params', {}), ensure_ascii=False)}

## 実行されたメソッド
{trace_summary}

## 検出対象（OWASP Top 10 2021）
1. **A01: Broken Access Control**
   - 直接オブジェクト参照（params[:id]でのオブジェクト取得）
   - 権限チェック不備（before_action不足）

2. **A02: Cryptographic Failures**
   - 平文パスワード保存
   - 弱い暗号化アルゴリズム使用

3. **A03: Injection**
   - SQL Injection（文字列補間 `#{{}}` 使用）
   - Code Injection（eval使用）
   - Command Injection（system, exec使用）

4. **A05: Security Misconfiguration**
   - デバッグ情報露出
   - 不適切なHTTPヘッダー

5. **A06: Vulnerable Components**
   - 古いgem使用
   - 既知の脆弱性を持つdependency

6. **A07: Authentication Failures**
   - 弱いパスワード検証
   - セッション管理不備

## 分析指示 - データフロー重視
- **重要**: 信頼できない入力（パラメータ）が危険なメソッドに直接流れているかを詳細に分析
- メソッド実行チェーンを追跡し、入力データがサニタイズされずに危険な処理に使われているか確認
- 以下の条件をすべて満たす場合のみ脆弱性として報告:
  1. リクエストパラメータが含まれている
  2. そのパラメータが適切なバリデーション/サニタイゼーション無しで使用されている
  3. 危険なメソッド（SQL実行、ファイル操作、システムコマンドなど）で使用されている
  4. 実際の攻撃が可能である
- 単純なパターンマッチングではなく、実際のデータフローを分析
- 潜在的リスクではなく、確実に悪用可能な脆弱性のみ報告

## 出力形式（JSON）
{{
  "vulnerabilities": [
    {{
      "owasp_category": "A01:2021|A02:2021|A03:2021|A05:2021|A06:2021|A07:2021",
      "type": "具体的な脆弱性タイプ",
      "severity": "low|medium|high|critical",
      "confidence": 0.0-1.0,
      "affected_method": "メソッド名",
      "line": 行番号,
      "description": "脆弱性の詳細説明（コード例は含めない）",
      "recommendation": "具体的な修正方法（コード例は含めない）"
    }}
  ]
}}

重要な出力規則:
- JSON形式で出力してください
- description と recommendation にはプレーンテキストのみ使用
- コード例、バッククォート、特殊文字は含めない
- 脆弱性が検出されない場合は "vulnerabilities": [] を返してください
"""
        return prompt
    
    def _format_execution_trace(self, execution_trace: List[Dict[str, Any]]) -> str:
        """Format execution trace for LLM analysis"""
        if not execution_trace:
            return "実行トレースがありません"
        
        formatted_lines = []
        for i, trace in enumerate(execution_trace[:20]):  # Limit to first 20 traces
            method = trace.get("method", "Unknown")
            file_location = trace.get("file", "unknown")
            line = trace.get("line", 0)
            source = trace.get("source", "").strip()
            context = trace.get("context", "")
            
            formatted_lines.append(f"""
{i+1}. **{method}** ({file_location}:{line})
   ```ruby
   {source}
   ```
   Context: {context}
""")
        
        if len(execution_trace) > 20:
            formatted_lines.append(f"\n... および他の{len(execution_trace) - 20}個のメソッド呼び出し")
        
        return "\n".join(formatted_lines)
    
    def _parse_vulnerability_response(self, response_content: str) -> List[Dict[str, Any]]:
        """Parse LLM response to extract vulnerabilities"""
        try:
            # Handle markdown-formatted JSON (```json ... ```)
            if '```json' in response_content:
                start_marker = response_content.find('```json') + 7
                end_marker = response_content.find('```', start_marker)
                if end_marker != -1:
                    json_content = response_content[start_marker:end_marker].strip()
                else:
                    # Fallback to finding JSON braces
                    json_content = response_content[start_marker:].strip()
            else:
                # Try to extract JSON from the response
                start_idx = response_content.find('{')
                end_idx = response_content.rfind('}') + 1
                
                if start_idx == -1 or end_idx == 0:
                    logger.warning("No JSON found in LLM response")
                    return []
                
                json_content = response_content[start_idx:end_idx]
            
            # Fix common JSON issues in LLM responses
            json_content = self._fix_json_content(json_content)
            parsed = json.loads(json_content)
            
            vulnerabilities = parsed.get("vulnerabilities", [])
            
            # Validate and clean up vulnerabilities
            valid_vulnerabilities = []
            for vuln in vulnerabilities:
                if self._validate_vulnerability(vuln):
                    valid_vulnerabilities.append(vuln)
                else:
                    logger.warning(f"Invalid vulnerability format: {vuln}")
            
            return valid_vulnerabilities
            
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON from LLM response: {e}")
            logger.debug(f"Response content: {response_content}")
            return []
        except Exception as e:
            logger.error(f"Error parsing vulnerability response: {e}")
            return []
    
    def _validate_vulnerability(self, vuln: Dict[str, Any]) -> bool:
        """Validate vulnerability structure"""
        required_fields = ["owasp_category", "type", "severity", "confidence"]
        
        for field in required_fields:
            if field not in vuln:
                return False
        
        # Validate OWASP category
        valid_categories = ["A01:2021", "A02:2021", "A03:2021", "A05:2021", "A06:2021", "A07:2021"]
        if vuln["owasp_category"] not in valid_categories:
            return False
        
        # Validate severity
        valid_severities = ["low", "medium", "high", "critical"]
        if vuln["severity"] not in valid_severities:
            return False
        
        # Validate confidence
        try:
            confidence = float(vuln["confidence"])
            if not (0.0 <= confidence <= 1.0):
                return False
        except (ValueError, TypeError):
            return False
        
        return True
    
    def _fix_json_content(self, json_content: str) -> str:
        """Fix common JSON formatting issues in LLM responses"""
        # Simple approach: just escape common problematic characters
        
        # First, handle backticks which are commonly used in code examples
        json_content = json_content.replace('`', '')
        
        # Handle Ruby interpolation syntax by removing the # 
        json_content = json_content.replace('#{', '{')
        
        return json_content