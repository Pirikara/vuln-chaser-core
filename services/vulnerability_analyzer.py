import json
import logging
from typing import Dict, List, Any
from .openrouter_client import OpenRouterClient

logger = logging.getLogger(__name__)

class VulnerabilityAnalyzer:
    def __init__(self):
        self.openrouter_client = OpenRouterClient()
        self.last_analysis_time = 0
        self.last_cost = 0.0
    
    async def analyze_batch(self, traces: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Analyze a batch of traces for vulnerabilities"""
        results = []
        
        for trace in traces:
            try:
                result = await self.analyze_single_trace(trace)
                results.append(result)
            except Exception as e:
                logger.error(f"Failed to analyze trace {trace.get('trace_id', 'unknown')}: {e}")
                results.append({
                    "trace_id": trace.get("trace_id", "unknown"),
                    "vulnerabilities": [],
                    "error": str(e)
                })
        
        return results
    
    async def analyze_single_trace(self, trace: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze a single trace for vulnerabilities"""
        prompt = self._build_vulnerability_prompt(trace)
        
        # Debug: Log the prompt being sent
        logger.info(f"ðŸ” VULNERABILITY ANALYSIS PROMPT for trace {trace.get('trace_id', 'unknown')}:")
        logger.info("=" * 80)
        logger.info(prompt)
        logger.info("=" * 80)
        
        messages = [
            {"role": "user", "content": prompt}
        ]
        
        response = await self.openrouter_client.chat_completion(messages)
        
        # Debug: Log the LLM response
        logger.info(f"ðŸ¤– LLM RESPONSE for trace {trace.get('trace_id', 'unknown')}:")
        logger.info("=" * 80)
        logger.info(response["content"])
        logger.info("=" * 80)
        
        # Update metrics
        self.last_analysis_time = response["response_time_ms"]
        self.last_cost = response["cost_usd"]
        
        # Parse LLM response
        vulnerabilities = self._parse_vulnerability_response(response["content"])
        
        return {
            "trace_id": trace["trace_id"],
            "vulnerabilities": vulnerabilities,
            "analysis_metadata": {
                "model": response["model"],
                "response_time_ms": response["response_time_ms"],
                "cost_usd": response["cost_usd"],
                "usage": response["usage"]
            }
        }
    
    def _build_vulnerability_prompt(self, trace: Dict[str, Any]) -> str:
        """Build comprehensive vulnerability detection prompt"""
        request_info = trace.get("request_info", {})
        execution_trace = trace.get("execution_trace", [])
        
        # Format execution trace for analysis
        trace_summary = self._format_execution_trace(execution_trace)
        
        prompt = f"""
ã‚ãªãŸã¯Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®å°‚é–€å®¶ã§ã™ã€‚ä»¥ä¸‹ã®Ruby on Rails ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œãƒˆãƒ¬ãƒ¼ã‚¹ã‚’åˆ†æžã—ã€OWASP Top 10 2021 ã«åŸºã¥ãè„†å¼±æ€§ã‚’æ¤œå‡ºã—ã¦ãã ã•ã„ã€‚

## ãƒªã‚¯ã‚¨ã‚¹ãƒˆæƒ…å ±
- Method: {request_info.get('method', 'UNKNOWN')}
- Path: {request_info.get('path', 'unknown')}
- Parameters: {json.dumps(request_info.get('params', {}), ensure_ascii=False)}

## å®Ÿè¡Œã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰
{trace_summary}

## æ¤œå‡ºå¯¾è±¡ï¼ˆOWASP Top 10 2021ï¼‰
1. **A01: Broken Access Control**
   - ç›´æŽ¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‚ç…§ï¼ˆparams[:id]ã§ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå–å¾—ï¼‰
   - æ¨©é™ãƒã‚§ãƒƒã‚¯ä¸å‚™ï¼ˆbefore_actionä¸è¶³ï¼‰

2. **A02: Cryptographic Failures**
   - å¹³æ–‡ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¿å­˜
   - å¼±ã„æš—å·åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ä½¿ç”¨

3. **A03: Injection**
   - SQL Injectionï¼ˆæ–‡å­—åˆ—è£œé–“ `#{{}}` ä½¿ç”¨ï¼‰
   - Code Injectionï¼ˆevalä½¿ç”¨ï¼‰
   - Command Injectionï¼ˆsystem, execä½¿ç”¨ï¼‰

4. **A05: Security Misconfiguration**
   - ãƒ‡ãƒãƒƒã‚°æƒ…å ±éœ²å‡º
   - ä¸é©åˆ‡ãªHTTPãƒ˜ãƒƒãƒ€ãƒ¼

5. **A06: Vulnerable Components**
   - å¤ã„gemä½¿ç”¨
   - æ—¢çŸ¥ã®è„†å¼±æ€§ã‚’æŒã¤dependency

6. **A07: Authentication Failures**
   - å¼±ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼
   - ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ä¸å‚™

## åˆ†æžæŒ‡ç¤º - ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼é‡è¦–
- **é‡è¦**: ä¿¡é ¼ã§ããªã„å…¥åŠ›ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼‰ãŒå±é™ºãªãƒ¡ã‚½ãƒƒãƒ‰ã«ç›´æŽ¥æµã‚Œã¦ã„ã‚‹ã‹ã‚’è©³ç´°ã«åˆ†æž
- ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè¡Œãƒã‚§ãƒ¼ãƒ³ã‚’è¿½è·¡ã—ã€å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ãŒã‚µãƒ‹ã‚¿ã‚¤ã‚ºã•ã‚Œãšã«å±é™ºãªå‡¦ç†ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
- ä»¥ä¸‹ã®æ¡ä»¶ã‚’ã™ã¹ã¦æº€ãŸã™å ´åˆã®ã¿è„†å¼±æ€§ã¨ã—ã¦å ±å‘Š:
  1. ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã¦ã„ã‚‹
  2. ãã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒé©åˆ‡ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³/ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ç„¡ã—ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹
  3. å±é™ºãªãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆSQLå®Ÿè¡Œã€ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã€ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒžãƒ³ãƒ‰ãªã©ï¼‰ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹
  4. å®Ÿéš›ã®æ”»æ’ƒãŒå¯èƒ½ã§ã‚ã‚‹
- å˜ç´”ãªãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒãƒ³ã‚°ã§ã¯ãªãã€å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã‚’åˆ†æž
- æ½œåœ¨çš„ãƒªã‚¹ã‚¯ã§ã¯ãªãã€ç¢ºå®Ÿã«æ‚ªç”¨å¯èƒ½ãªè„†å¼±æ€§ã®ã¿å ±å‘Š

## å‡ºåŠ›å½¢å¼ï¼ˆJSONï¼‰
{{
  "vulnerabilities": [
    {{
      "owasp_category": "A01:2021|A02:2021|A03:2021|A05:2021|A06:2021|A07:2021",
      "type": "å…·ä½“çš„ãªè„†å¼±æ€§ã‚¿ã‚¤ãƒ—",
      "severity": "low|medium|high|critical",
      "confidence": 0.0-1.0,
      "affected_method": "ãƒ¡ã‚½ãƒƒãƒ‰å",
      "line": è¡Œç•ªå·,
      "description": "è„†å¼±æ€§ã®è©³ç´°èª¬æ˜Žï¼ˆã‚³ãƒ¼ãƒ‰ä¾‹ã¯å«ã‚ãªã„ï¼‰",
      "recommendation": "å…·ä½“çš„ãªä¿®æ­£æ–¹æ³•ï¼ˆã‚³ãƒ¼ãƒ‰ä¾‹ã¯å«ã‚ãªã„ï¼‰"
    }}
  ]
}}

é‡è¦ãªå‡ºåŠ›è¦å‰‡:
- JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„
- description ã¨ recommendation ã«ã¯ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã¿ä½¿ç”¨
- ã‚³ãƒ¼ãƒ‰ä¾‹ã€ãƒãƒƒã‚¯ã‚¯ã‚©ãƒ¼ãƒˆã€ç‰¹æ®Šæ–‡å­—ã¯å«ã‚ãªã„
- è„†å¼±æ€§ãŒæ¤œå‡ºã•ã‚Œãªã„å ´åˆã¯ "vulnerabilities": [] ã‚’è¿”ã—ã¦ãã ã•ã„
"""
        return prompt
    
    def _format_execution_trace(self, execution_trace: List[Dict[str, Any]]) -> str:
        """Format execution trace for LLM analysis"""
        if not execution_trace:
            return "å®Ÿè¡Œãƒˆãƒ¬ãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“"
        
        formatted_lines = []
        for i, trace in enumerate(execution_trace[:20]):  # Limit to first 20 traces
            method = trace.get("method", "Unknown")
            file_location = trace.get("file", "unknown")
            line = trace.get("line", 0)
            source = trace.get("source", "").strip()
            context = trace.get("context", "")
            
            formatted_lines.append(f"""
{i+1}. **{method}** ({file_location}:{line})
   ```ruby
   {source}
   ```
   Context: {context}
""")
        
        if len(execution_trace) > 20:
            formatted_lines.append(f"\n... ãŠã‚ˆã³ä»–ã®{len(execution_trace) - 20}å€‹ã®ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—")
        
        return "\n".join(formatted_lines)
    
    def _parse_vulnerability_response(self, response_content: str) -> List[Dict[str, Any]]:
        """Parse LLM response to extract vulnerabilities"""
        try:
            # Handle markdown-formatted JSON (```json ... ```)
            if '```json' in response_content:
                start_marker = response_content.find('```json') + 7
                end_marker = response_content.find('```', start_marker)
                if end_marker != -1:
                    json_content = response_content[start_marker:end_marker].strip()
                else:
                    # Fallback to finding JSON braces
                    json_content = response_content[start_marker:].strip()
            else:
                # Try to extract JSON from the response
                start_idx = response_content.find('{')
                end_idx = response_content.rfind('}') + 1
                
                if start_idx == -1 or end_idx == 0:
                    logger.warning("No JSON found in LLM response")
                    return []
                
                json_content = response_content[start_idx:end_idx]
            
            # Fix common JSON issues in LLM responses
            json_content = self._fix_json_content(json_content)
            parsed = json.loads(json_content)
            
            vulnerabilities = parsed.get("vulnerabilities", [])
            
            # Validate and clean up vulnerabilities
            valid_vulnerabilities = []
            for vuln in vulnerabilities:
                if self._validate_vulnerability(vuln):
                    valid_vulnerabilities.append(vuln)
                else:
                    logger.warning(f"Invalid vulnerability format: {vuln}")
            
            return valid_vulnerabilities
            
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON from LLM response: {e}")
            logger.debug(f"Response content: {response_content}")
            return []
        except Exception as e:
            logger.error(f"Error parsing vulnerability response: {e}")
            return []
    
    def _validate_vulnerability(self, vuln: Dict[str, Any]) -> bool:
        """Validate vulnerability structure"""
        required_fields = ["owasp_category", "type", "severity", "confidence"]
        
        for field in required_fields:
            if field not in vuln:
                return False
        
        # Validate OWASP category
        valid_categories = ["A01:2021", "A02:2021", "A03:2021", "A05:2021", "A06:2021", "A07:2021"]
        if vuln["owasp_category"] not in valid_categories:
            return False
        
        # Validate severity
        valid_severities = ["low", "medium", "high", "critical"]
        if vuln["severity"] not in valid_severities:
            return False
        
        # Validate confidence
        try:
            confidence = float(vuln["confidence"])
            if not (0.0 <= confidence <= 1.0):
                return False
        except (ValueError, TypeError):
            return False
        
        return True
    
    def _fix_json_content(self, json_content: str) -> str:
        """Fix common JSON formatting issues in LLM responses"""
        # Simple approach: just escape common problematic characters
        
        # First, handle backticks which are commonly used in code examples
        json_content = json_content.replace('`', '')
        
        # Handle Ruby interpolation syntax by removing the # 
        json_content = json_content.replace('#{', '{')
        
        return json_content